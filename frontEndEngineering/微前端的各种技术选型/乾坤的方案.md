## 基座模式的代表 qiankun.js (基于single-spa)
qiankun是一个很经典的基座模式下的微服务方案，但是在使用成本上来说是有点大的，它对代码的侵入型很强，如果要改造的话，从 webpack、代码、路由等等都要做一系列的适配

|  能力  | 现状 |
|  ---  | ---  |
|  通讯与状态管理 | 1、初始化状态通过props传入子组件   
2、qiankun通过initGlobalState, onGlobalStateChange, setGlobalState实现主应⽤的全局状态管理，然后默认会通过props将通信⽅法传递给⼦应⽤，但是本质上还是通过发布 - 订阅的方式来进行通讯  
3、主子应用localStrage、cookie可共享 所以在通讯上并不是很完美  |
|  js和css隔离  | 提供js和css隔离，但是在js的沙箱方面依然有不少坑有问题 |
|  预加载 | 做了静态资源的预加载能力  |
|  公共依赖的处理  | 文档内写明不推荐，但是硬要的话可以在微应用中将公共依赖配置成 external，然后在主应用中导入这些公共依赖的  |
|  路由管理  | 1、每个子应用中注册，然后由主应用进行管理，主应用的路由实例通过 props 传给微应用，微应用这个路由实例跳转  
2、注册微应用的基础配置信息。当浏览器 url 发生变化时，会自动检查每一个微应用注册的 activeRule 规则，符合规则的应用将会被自动激活  
3、页面上不能同时显示多个依赖于路由的微应用，因为浏览器只有一个 url，如果有多个依赖路由的微应用同时被激活，那么必定会导致其中一个 404。 (因为基于路由匹配，所以无法同时激活多个子应用)  |
|  html entry  | 支持  |
| 应用保活  | 应用保活	无法支持子应用保活  |

## 总结
qiankun的优点在于它对单个应用的侵入性小，可以很好的和现有的项目进行结合，并且提供了很好的路由管理能力，但是缺点在于它对子应用的侵入性大，并且无法很好的支持子应用的保活，以及在通讯和状态管理上并不是很完美，所以如果想要使用qiankun，需要做好充分的调研和准备，并且需要有足够的时间和精力去进行改造和适配。

## 手写一个乾坤的js沙箱


